---
layout: post
current: post
cover: 'assets/images/post-cover/2022-required.jpg'
socialcover: 'assets/images/post-cover/2022-required-s.jpg'
slug: required-dove-stiamo-andando-non-c-e-bisogno-di-required
title: '[Required]!? Dove stiamo andando non c'è bisogno di... [Required]!'
date: 2022-03-04 09:00:00
category : [tech]
tags: [software, functional, programming, howto]
author: [moreno]
---

<div class="post-intro">
Quando realizziamo una Web API con ASP.NET Core, è prassi decorare le proprietà obbligatorie dei nostri modelli con l'attributo `[Required]`. In certi casi però questo ci costringe ad accettare dei compromessi. Vedremo quindi una tecnica alternativa: un approccio che sfrutta la nullabilità dei tipi e il deserializzatore JSON per fare a meno di tale attributo. Questo ci porterà anche a valutare lo stato di maturità di `System.Text.Json`.
</div>

Su GitHub trovi un [progetto dimostrativo](https://github.com/Moreno-Gentili/we-dont-need-required) in C#.

## Il tuo modello! Bisogna fare qualcosa per il tuo modello!
Usare l'attributo `[Required]` è il modo canonico per indicare a chi consuma la nostra Web API che deve obbligatoriamente fornire un valore non vuoto. Prendiamo come esempio una classe che reca i criteri di filtro su un catalogo di prodotti.

```
codice
```

Grazie alla presenza dell'attributo `[Required]`, l'obbligatorietà è ben evidente anche nella documentazione Swagger dell'operazione che riceve un oggetto di quel tipo.

```
immagine
```

Tuttavia, all'atto pratico, il client potrà omettere tale valore e l'infrastruttura di ASP.NET Core sopperirà alla mancanza del dato fornendo esso stessa un default.

> Hai dimenticato di valorizzare un valore `bool` obbligatorio? Fa niente, facciamo finta che tu abbia fornito `false`.

In molte situazioni questo è un problema perché tende a nascondere la presenza di bug: il client avrà **scelto** di omettere tale proprietà o si sarà trattato di una sua dimenticanza? Non avrà mica sbagliato a digitare il nome del campo?

> Per fornire un'esperienza di utilizzo migliore a chi si integra con la nostra applicazione, la Web API dovrebbe essere progettata sia per segnalare puntualmente la mancanza di valori obbligatori che la presenza di campi sconosciuti.

Vediamo come poterlo attuare.

## Ci... *dobbiamo*... riuscire
La soluzione più facile, ma anche più problematica, consiste nel dichiarare la proprietà come nullabile.

```
public class Foo
{
  [Required]
  public bool? Value { get; set; }
}
```

Infatti, se eseguiamo di nuovo la richiesta, ora il client verrà informato del problema perché il valore di default per `bool?` è `null`, che viene invalidato dalla presenza del `[Required]`

```
immagine
```

Per quanto immediata che sia, questa soluzione però porta con sé ha un effetto indesiderato.

> Aspetta un minuto, mi stai dicendo che hai definito una proprietà obbligatoria... nullabile?

Pur di "assecondare" questa particolarità di ASP.NET Core, abbiamo accettato uno scomodo compromesso che tornerà a confondendoci le idee in altri punti dell'applicazione.

```
immagine
```

Il primo pensiero sarà: "Uhm, non era mica obbligatoria quella proprietà?"


##  Accidenti, ho rotto il modello

Accettare compromessi questo questo spesso vuol dire rallentare lo sviluppoe facilitare l'introduzione di bug. Vediamo se esiste un modo migliore.

> L'obbligatorietà di una proprietà può essere espressa semplicemente scegliendo un tipo non nullabile.

Questo è vero non solo per i value type come `int` e `bool` ma anche per qualsiasi reference type come gli array o le classi definite da noi. La nullabilità viene espressa usando il carattere `?` come suffisso al nome del tipo.

| Obbligatorio   | Facoltativo |
|----------|-------------|
| int | int? |
| bool | bool? |
| string[] | string[]? |
| Address | Address? |

Da C# 8, infatti, possiamo abilitare i [Nullable Reference Types](https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references) aggiungendo quanto segue nel file di progetto (.csproj). Questa è anche l'impostazione predefinita che Microsoft ha usato nei template di progetto .NET 6.

```
<PropertyGroup>
  <Nullable>enable</Nullable>
</PropertyGroup>
```

Inoltre, usando i [record](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record) introdotti con C# 9, possiamo usare una sintassi molto succinta per tenere separate visisamente le proprietà obbligatorie da quelle facoltative.

```
codice
```

Il model binder di ASP.NET Core è perfettamente in grado di lavorare con i record e con le proprietà *init-only* usate nell'esempio.

> Abbiamo progettato il modello in totale libertà, senza essere minimamente influenzati dalle particolarità dell'infrastuttura sottostante.

## Questo rende possibile validare il modello: il deserializzatore!
Ora dobbiamo concentrarci sula parte infrastrutturale di ASP.NET Core, che deve essere configurata affinché assecondi le nostre scelte di modellazione. Per prima cosa, impediamo che vengano usati dei default. In mancanza di valori obbligatori, la Web API dovrebbe restituire un errore `400 Bad Request`.

```
diagramma
```

Questo è un compito che possiamo affidare al deserializzatore JSON. Essendo ASP.NET Core un framework estremamente estendibile, possiamo scegliere liberamente il deserializzatore da usare.
- `Newtonsoft.Json` è la soluzione più matura e "storica" che ha accompagnato ASP.NET sin dal .NET Framework;
- `System.Text.Json` è il sostituto più recente, usato da Microsoft da ASP.NET Core 3.0. È più snello e perciò anche più performante.

```
immagine
```

Tuttavia, se esaminiamo [la tabella di confronto](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to?pivots=dotnet-6-0), scopriamo che molte funzionalità non sono ancora implementate o richiedono laboriosi workaround.

> Le migliori performance di `System.Text.Json`, tuttavia, sono controbilanciate da carenze nelle funzionalità offerte.

A causa di queste limitazioni non ci è possibile, ad oggi, usare `System.Text.Json` per mettere in atto questa soluzione. Torniamo invece a valutare `Newtonsoft.Json`.

## La nostra unica possibilità di riparare il presente è... nel passato

Ricorrere a `Newtonsoft.Json` in nuove applicazioni è ancora possibile e lo facciamo quando, in casi come questo, ci interessa beneficiare delle sue maggiori funzionalità pur accettando un lieve calo prestazionale.

> Valutiamo sempre, caso per caso, quale sia la scelta più opportuna per lo specifico progetto che stiamo realizzando. Non esistono soluzioni universalmente valide.

Per implementarlo, cominciamo con l'aggiungere un riferimento al pacchetto NuGet `Newtonsoft.Json` alla nostra applicazione ASP.NET Core Web API.

```
dotnet add package Newtonsoft.Json
dotnet add package Swashbuckle.AspNetCore.Newtonsoft
```

Poi, integriamo così la chiamata a `AddControllers` chi si trova nel metodo `ConfigureServices` della classe `Startup`. Se stiamo usando il nuovo [Minimal Hosting Model](https://docs.microsoft.com/en-us/aspnet/core/migration/50-to-60-samples) introdotto con .NET 6, troveremo la chiamata nella classe `Program`.

```
codice
```

Integriamo anche la documentazione Swagger.

```
codice
```

Il `RequirePropertiesContractResolver` è appunto l'organo che ci consentirà di richiedere l'immissione delle proprietà non nullabili.

```
codice
```

La api `NullabilityInfoContext` ci permette di sapere a runtime se una proprietà è stata dichiarata.
Realizzare un ContractResolver come questo ci evita di sporcare il modello con attributi che riguardano il serializzatore. In questo modo, la responsabilità di esporre su HTTP il modello in accordo con l'intenzione dello sviluppatore è completamente trasparente e disaccoppiata dal modello stesso.

## Se ti ci metti con impegno, raggiungi qualsiasi risultato
Ora che tutti i componenti sono al loro posto, il client otterrà un errore sia che ometta valori obbligatori, sia che fornisca proprietà inesistenti.

```
immagine
```

La nostra Web API ora fornisce un aiuto maggiore a coloro che si integrano con la nostra applicazione e renderà evidenti, in maniera precoce, gli eventuali errori nel payload.

> Questo *far cortese* non è solo un modo fine a sé stesso di migliorare la vita a chi usa il nostro software. È anche una strategia che riduce efficacemente il tempo dedicato alle richieste di assistenza.

## Siamo sul pesante!
Davvero? Verifichiamolo! Ricordiamoci sempre di misurare il costo prestazionale delle scelte architetturali che prendiamo, soprattutto se coinvolgono la *reflection* come in questo caso. In ogni applicazione, l'ago della bilancia si posizionerà in un certo punto tra funzionalità e prestazioni. Noi, come sviluppatori, dovremmo essere consapevoli di quale sia questo punto e agire di conseguenza per spostarlo se non dovesse soddisfarci.

```
grafico
```
Insomma, nessun problema con... *la forza di gravità*. Per ottenere queste performance, il [progetto dimostrativo](https://github.com/Moreno-Gentili/we-dont-need-required) attua una politica di caching dei `JsonObjectContract`. Dopo la sua iniziale creazione, infatti, l'oggetto può essere riutilizzato tale e quale per ogni successiva richiesta.

## Il prossimo novembre ti rimanderò indietro... nel futuro!

Ad ogni nuovo rilascio, .NET porta con sé numerose novità e .NET 7 confermerà questo trend quando verrà ufficialmente rilasciato a novembre 2022.

L'elenco di [funzionalità pianificate per System.Text.Json in .NET 7](https://github.com/dotnet/runtime/issues/63762) dimostra come Microsoft voglia, a poco a poco, colmare il divario funzionale con `Newtonsoft.Json`.

> System.Text.Json esporrà nuove API per realizzare e configurare Contract Resolver.

In futuro, è auspicabile che la tecnica mostrata in questo articolo possa essere messa in pratica usando `System.Text.Json`, per di più con performance migliori, date le [ottimizzazioni certosine fatte da Microsoft](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/#json) di rilascio in rilascio.

Che ne pensi, useresti questa soluzione? Guarda come è stata implementata nel [progetto dimostrativo](https://github.com/Moreno-Gentili/we-dont-need-required) su GitHub.



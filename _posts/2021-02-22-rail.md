---
layout: post
current: post
cover: 'assets/images/post-cover/20200724-smart-working.jpg'
socialcover: 'assets/images/post-cover/20200724-smart-working-s.jpg'
slug: rop-csharp9
title: 'ROP con c#9'
date: 2021-02-22 09:00:00
category : tech
tags: [functional, programming, howto]
author: [gianni, alberto]
---
<div class="post-intro">La parola "Smartworking" ha registrato su Google Trends Italia un +120% di ricerche. Si è sentito di tutto in questi mesi: dalla sindrome della caverna, a proiezioni sul futuro di come sarà il <a href="https://www.corriere.it/tecnologia/cards/occhi-secchi-problemi-posturali-obesita-susan-l-elaborazione-grafica-peggiori-effetti-25-anni-smart-working/piacere-susan_principale.shtml" target="_blank">nostro fisico dopo venticinque anni di smartworking</a>. 
</div>

Recentemente abbiamo avuto l’esigenza di integrare un servizio di _firma digitale_ in un nostro progetto. Il servizio richiede l’esecuzione di **diversi step consecutivi** per poter essere completato:
*   autorizzazione
*   configurazione del processo e caricamento dei files
*   invio richiesta di firma

In caso di risultato positivo l’applicativo deve propagare l’identificativo del processo di firma al resto del “programma”; in caso di errore deve rilevare con il maggior dettaglio possibile la motivazione e lo step nel quale il processo si è interrotto.

Per poter interagire con le API del provider abbiamo utilizzato un SDK che fornisce un metodo per ciascuna delle operazioni da svolgere. Ogni metodo restituisce un risultato in caso di successo oppure un’eccezione `SignDocumentException` in caso di errore. 

Per nostra _sfortuna_, l’eccezione è identica per tutte le operazioni e di conseguenza “catchare” `SignDocumentException` **non è sufficiente per distinguere il tipo di errore che si è verificato** e differenziare la sua gestione (come ad esempio restituire un feedback all’utente che permetta di capire dove il processo si è interrotto).

```c#
static Guid SignDocument(string fileName, string userName)
{
    Guid token;
    LoadResult loadResult;
    try
    {
        token = SignDocument.Authorize(userName);
    }
    catch (SignDocumentException exc)
    {
         throw new Exception("Errore durante la fase di autorizzazione.", exc);
    }

     try
     {
         loadResult = SignDocument.Load(token, fileName
     }
     catch (SignDocumentException exc)
     {
         throw new Exception("Errore durante la fase di caricamento del file.", exc);
     }

     try
     {
         return SignDocument.Sign(loadResult);
     }
     catch (SignDocumentException exc)
     {
         throw new Exception("Errore durante la fase di invio del file al provider di firma digitale.", exc);
     }
}
```

Ogni step del flusso è implementato con un blocco **try... catch ad-hoc** che racchiude il metodo esposto dall’SDK. Ogni blocco può restituire un risultato oppure intercettare l’eccezione e lanciarne un’altra con un messaggio più appropriato.

L’implementazione è di per sé “pulita”, ma la ripetizione del costrutto try ... catch ci ha fatto “storcere il naso” e ci ha spinto ad investigare soluzioni alternative.


# Prima evoluzione: soluzione con tuple

Per realizzare la prima soluzione alternativa, abbiamo introdotto l’uso delle **tuple**. 

Per ogni step del processo di firma digitale abbiamo predisposto una funzione in grado di indicare, attraverso un valore booleano della tupla di ritorno, l’esito dell’operazione.



```c#
static (bool, Guid) Authorize()
{
     try
     {
          Guid token = SignDocument.Authorize();
          return (true, token);
     }
     catch (Exception)
     {
           return (false, Guid.Empty);
      }
 }
```


Di seguito il risultato finale della soluzione ottenuta.


```c#
static Guid SignDocument(string fileName, string userName)
        {
            (bool successAuth, Guid token) = Authorize(userName);
            if (!successAuth)
                throw new Exception("Errore durante la fase di autorizzazione.");

            (bool successLoad, LoadResult loadResult) = Load(token, fileName);
            if (!successLoad)
                throw new Exception("Errore durante la fase di caricamento del file.");

            (bool successSend, Guid signId) = Sign(loadResult);
            if (!successSend)
                throw new Exception("Errore durante la fase di invio del file al provider di firma digitale.");

            return signId;
        }       
```

La situazione migliora, ma ogni volta è necessario ripetere il costrutto _if_.

Ci siamo chiesti se con le **nuove funzionalità introdotte da .net 5 e C#9**, ed in particolare con l’uso del **pattern matching**, si fosse possibile evolvere ulteriormente l’implementazione.

# Seconda evoluzione: Railway Oriented Programming

Cercando ulteriori soluzioni al nostro “problema”, siamo venuti a conoscenza della metodologia Railway Oriented Programming presentata per la prima volta da Scott Wlaschin durante la [conferenza NDC 2014](https://vimeo.com/97344498).

La metodologia, tipica della **programmazione funzionale**, descrive la soluzione a questo genere di problemi attraverso la **metafora con una linea ferroviaria** costituita da due binari (_tracks_): il binario verde che rappresenta il successo ed il binario rosso che rappresenta l’errore. Il programma inizia ad eseguire la sequenza di operazioni previste lungo il binario verde; quando un’operazione fallisce, l’esecuzione si sposta lungo il binario rosso fino al termine della sequenza delle operazioni.

(QUI IMMAGINE)

Ogni step rappresenta un metodo e può essere visto come un **raccordo** che si “collega” ad entrambi i binari della linea; in caso di errore, comporta il **dirottamento del flusso** di esecuzione dal binario del successo al binario dell’errore. 


Ogni metodo/blocco ha la facoltà di: 

*  _non eseguire_ alcuna operazione se uno dei metodi precedenti ha prodotto un **errore**;
*  _eseguire_ l’operazione se tutti i metodi precedenti sono stati **completati con successo** e produrre un nuovo risultato, eventualmente utilizzando il risultato del metodo precedente.

Cercando di applicare questo approccio al nostro scenario e sfruttando i costrutti di .net 5 e C# 9, abbiamo evoluto il programma fino alla seguente soluzione:


```c#
public static Result<SignData> SignDocument(string fileName, string userName)
{
    SignData input = new SignData(fileName, userName);
    return Authorize(input)
                    .Then(Load)
                    .Then(Sign)
                    .ToResult();
}
```
<br/>

Come siamo arrivati a questo risultato? Siamo partiti rappresentando i binari (tracks) attrverso le interfacce `ISuccessfulTrack` (binario verde) e `IErrorTrack` (binario rosso).

<br/>
```c#
    public interface ITrack<T> { }
    
    public interface ISuccessfulTrack<T> : ITrack<T>
    {
        T GetResult();
    }
    
    public interface IErrorTrack<T> : ITrack<T>
    {
        string GetError();
    }
```
<br/>

Per l’implementazione dei binari abbiamo introdotto **l’uso dei [record](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/exploration/records)**. Ecco i nostri binari:

<br/>
```c#
public record Success<T>(T Result) : ISuccessfulTrack<T>
    {
        public T GetResult() => Result;
    }

    public record Error<T>(string ErrorMessage) : IErrorTrack<T>
    {
        public string GetError() => ErrorMessage;
    }
```
<br/>

Il metodo _Then_, sfruttando la potenza del pattern matching di C#9, ci consente di eseguire la funzione vera e propria oppure, se siamo già sul binario rosso, terminare l’esecuzione del programma **“senza passare dal via”**.

<br/>
```c#
        public static ITrack<Tout> Then<Tin, Tout>(this ITrack<Tin> prevResult, Func<Tin, ITrack<Tout>> doWork) => prevResult switch
        {
            ISuccessfulTrack<Tin> success => doWork(success.GetResult()),
            IErrorTrack<Tin> error => new Error<Tout>(error.GetError()),
            _ => new Error<Tout>("Invalid input type")
        };
```

<br/>
Se siamo sul binario verde, la funzione da eseguire è quella definita dal metodo _doWork_ passato come argomento al metodo _Then_.

Per rappresentare il risultato finale e quindi “unificare” i due binari abbiamo introdotto la classe `Result`. La proprietà `IsSuccess` permette al chiamante di gestire facilmente il risultato del nostro processo.
<br/>

```c#
public class Result<T>
    {
        public bool IsSuccess { get; init; }
        public T Success { get; init; }
        public string Error { get; init; }

        public static Result<T> FromSuccessfulTrack(ISuccessfulTrack<T> successResult) => new Result<T> { 
                IsSuccess = true,
                Success = successResult.GetResult(),
                Error = string.Empty
            };
        public static Result<T> FromErrorTrack(IErrorTrack<T> errorResult) => new Result<T>
        {
            IsSuccess = false,
            Success = default(T),
            Error = errorResult.GetError()
        };
    }
```
<br/>
Di seguito il metodo _ToResult_ che unifica i due binari
<br/>
```c# 
public static Result<Tin> ToResult<Tin>(this ITrack<Tin> prevResult) => prevResult switch
        {
            ISuccessfulTrack<Tin> success => Result<Tin>.FromSuccessfulTrack(success),
            IErrorTrack<Tin> error => Result<Tin>.FromErrorTrack(error),
            _ => Result<Tin>.FromErrorTrack(new Error<Tin>("Invalid input type in Result method."))
        };
```
<br/>
Il [record](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/exploration/records) `SignData ` ha lo scopo di collezionare i dati necessari per l’esecuzione del processo, sia i parametri di input che i risultati parziali dei singoli step.
<br/>

```c#
public record SignData(string FileName, string UserName)
    {
        public Guid AuthorizationToken { get; init; }
        public LoadResult LoadResult { get; init; }
        public Guid SignId { get; init; }
    };
```
<br/>

Ad ogni step viene generata una nuova istanza immutabile di `SignData` sfruttando il costrutto [with](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/with-expression) di .net 5 e C#9 che ci consente di **valorizzare le informazioni “strada facendo”**, proprio come un treno che viaggia lungo i binari.

Ognuno dei metodi che consentono l’implementazione del flusso, restituirà un oggetto `Success` oppure `Error` in base all’esito dell’operazione. Ciò consentirà al **blocco successivo** di proseguire sul **binario verde** oppure su quello **rosso**.
<br/>
```c#
public static ITrack<SignData> Load(SignInput input)
        {
            try
            {
                LoadResult loadResult = SignDocument.Load(input.AuthorizationToken, input.FileName);
                return new Success<SignData>(input with { LoadResult = loadResult });
            }
            catch (Exception)
            {
                return new Error<SignData>("Errore durante la fase di caricamento del file.");
            }
        }
```
<br/>
# Conclusioni

Indipendentemente dalla nostra implementazione, volutamente semplificata, l’applicazione di questa metodologia tipica della **programmazione funzionale**, ci ha consentito di standardizzare la modalità con la quale ogni metodo tratta l’errore e di concentrare l’attenzione, in ogni metodo, sulla trasformazione dell’input per la produzione di un risultato intermedio.

Sicuramente la semplicità del risultato finale si ottiene a patto di “scrivere” un numero maggiore di righe codice _under-the-hood_ per la creazione della struttura di gestione delle _tracks_, che però può essere **riutilizzata** per gestire scenari analoghi.

## Link

*   [https://fsharpforfunandprofit.com/rop/](https://fsharpforfunandprofit.com/rop/)
*   [https://github.com/louthy/language-ext](https://github.com/louthy/language-ext)
*   [https://fsharpforfunandprofit.com/rop/#monads](https://fsharpforfunandprofit.com/rop/#monads)
*   [https://fsharpforfunandprofit.com/posts/recipe-part2/](https://fsharpforfunandprofit.com/posts/recipe-part2/)
*   [https://davidelettieri.it/rop/'tagged/union'/'railway/oriented/programming'/c%23/2020/04/04/railway-oriented-programming-with-c.html](https://davidelettieri.it/rop/'tagged/union'/'railway/oriented/programming'/c%23/2020/04/04/railway-oriented-programming-with-c.html)
*   [https://anthonygiretti.com/2020/06/23/introducing-c-9-improved-pattern-matching/](https://anthonygiretti.com/2020/06/23/introducing-c-9-improved-pattern-matching/)
